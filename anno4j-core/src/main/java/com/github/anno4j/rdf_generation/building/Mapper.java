package com.github.anno4j.rdf_generation.building;

import java.io.IOException;
import java.util.List;
import java.util.Map;

import org.openrdf.query.algebra.If;

import com.github.anno4j.rdf_generation.fragments.Fragment;
import com.github.anno4j.rdf_generation.fragments.Fragments;
import com.github.anno4j.rdf_generation.generation.RdfFileGenerator;
import com.github.anno4j.rdf_generation.validation.Validator;
import com.google.common.reflect.ClassPath;

public class Mapper {

	/**
	 * Returns the range for a property which was generated by mapping the java
	 * return value to the RDFS equivalent.
	 * 
	 * @param propID   The ID of the method whose return value should be mapped to a
	 *                 RDFS range.
	 * @param rangeMap The map where all methods and their return values are stored.
	 * @return The range of the property.
	 * @throws IOException
	 */
	public static String mapJavaReturn(Integer propID, Map<Integer, String> rangeMap) throws IOException {
		for (Map.Entry<Integer, String> e : rangeMap.entrySet()) {
			if (e.getKey() == propID) {
				return mapToRDFRange(e.getValue());
			}
		}
		return null;
	}

	/**
	 * Maps a specific java return value to a RDFS range uri. If the extracted
	 * return value has a relation to a primitive datatype in java, the equivalent
	 * datatype uri will be returned. If the java return value matches one of the
	 * names of the converted classes, the annotation value of that class will be
	 * returned.
	 * 
	 * @param javavalue The java return type of a method.
	 * @return The range of the property converted from the method.
	 * @throws IOException
	 */
	private static String mapToRDFRange(String javavalue) throws IOException {
		List<Fragment> fraglist = Fragments.getFragments();
		if (isDatatypePrimitive(javavalue, fraglist)) {
			for (int i = 0; i < fraglist.size(); i++) {
				String javaequiv = fraglist.get(i).getJavaEquiv(); // void or ""
				if (javaequiv.equals(javavalue)) {
					return javaequiv;
				} else {
					if (fraglist.get(i).hasRelationTo(javavalue)) {
						return fraglist.get(i).getURI(); 
					}
				}
			}
		} else { // isDatatypeKomplex
			if (getComplexDatatypeByList(javavalue) != null) {
				return getComplexDatatypeByList(javavalue);
			} else {
				return getComplexDatatypeBySearch(javavalue);
			}
		}
//		return Validator.;
		return null; // vorerst ohne Validierung
	}

	/**
	 * 
	 * @param javavalue
	 * @return
	 * @throws IOException
	 */
	private static String getComplexDatatypeBySearch(String javavalue) throws IOException {
		return searchAnnotFromClass(Extractor.getPackages(), Extractor.extractLastName(javavalue));
	}

	/**
	 * 
	 * @param javavalue
	 * @return
	 */
	private static String getComplexDatatypeByList(String javavalue) {
		for (Map.Entry<Integer, String> e : Extractor.getClassNames().entrySet()) {
			// if the return value is one of the classes in the package...
			if (javavalue.endsWith(e.getValue())) {
				for (Map.Entry<Integer, String> e1 : Extractor.getClassValues().entrySet()) {
					// ...then find its annotation value and return it a the range of the property
					if (e.getKey() == e1.getKey()) {
						return e1.getValue(); // may be a self defined type eg Player or Pet.
					}
				}
			}
		}
		return null;
	}

	/**
	 * 
	 * @param javavalue
	 * @param fraglist
	 * @return
	 */
	private static boolean isDatatypePrimitive(String javavalue, List<Fragment> fraglist) {
		for (int i = 0; i < fraglist.size(); i++) {
			// if the return value matches a primitive datatype
			if (fraglist.get(i).hasRelationTo(javavalue)) { // alle primitiven datentypen auÃŸer void
				return true;
			}
		}
		return false;
	}

	/**
	 * 
	 * @param pathname
	 * @param classname
	 * @return
	 * @throws IOException
	 */
	private static String searchAnnotFromClass(String pathname, String classname) throws IOException {
		String packageabove = extractPackage(pathname);
		String newclassname = extendPath(packageabove, classname);
		Class<?> clazz = loadClass(newclassname);
//		System.out.println("CLAZZ: " + clazz);
		if (clazz != null) {
			return Extractor.extractClassAnnotValue(clazz);
		} else {
			// Validator.
			return null; // for now good enough
		}
	}

	/**
	 * 
	 * @param pathname
	 * @return
	 */
	private static String extractPackage(String pathname) {
		int beginIndex = 0;
		int endIndex = pathname.lastIndexOf(".");
		return pathname.substring(beginIndex, endIndex);
	}

	/**
	 * 
	 * @param pathname
	 * @param classname
	 * @return
	 */
	private static String extendPath(String pathname, String classname) {
		return pathname + "." + classname;
	}

	/**
	 * 
	 * @param name
	 * @return
	 * @throws IOException
	 */
	private static Class<?> loadClass(String name) throws IOException {
		final ClassLoader loader = Thread.currentThread().getContextClassLoader();
		// Start reader by specifying for example how the name of the package "starts
		// with"
		for (final ClassPath.ClassInfo info : ClassPath.from(loader).getTopLevelClasses()) {
			if (info.getName().matches(name)) {
				final Class<?> clazz = info.load();
				return clazz;
			}
		}
		return null;
	}
}
